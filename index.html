<html>
    <head>
        <title>My first three.js app</title>
        <style>
            body { margin: 0; }
            canvas { display: block; }
        </style>
    </head>
    <body>
        <script src="three.js-master/build/three.js"></script>
        <script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
 
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            var controls = new THREE.OrbitControls( camera, renderer.domElement );
 
            camera.position.z = 10;
 
            var angle = 22.5 * Math.PI/180;
            var axiom = 'X';
            var sentence = axiom;
            var len = 1;
 
            var rules = [];
            /*
            rules[0] = {
                a: 'F',
                b: 'F+F-F-F+F'
            };*/
            
            rules[0] = {
                a: 'X',
                b: 'F+[[F]-X]-F[-FX]+X'
            };
            
            rules[1] = {
                a: 'F',
                b: 'FF' 
            };
 
            function generate() {
                //len *= 0.5;
                let nextSentence = '';
                for (let i = 0; i < sentence.length; i++) {
                    let current = sentence.charAt(i);
                    let found = false;
                    for (let j = 0; j < rules.length; j++) {
                        if (current == rules[j].a) {
                            found = true;
                            nextSentence += rules[j].b;
                            break;
                        }
                    }
                    if (!found) {
                        nextSentence += current;
                    }
                }
                sentence = nextSentence;
                
                console.log(sentence);
                turtle();
            }
 
            
            
 
            
            var mat = [];
 
            mat = new THREE.Matrix4();
            mat.set( 1,0,0,0,
                    0,1,0,0,
                    0,0,1,0,
                    0,0,0,1);

            let geometry = new THREE.CylinderGeometry(1, 1, len, 32 );
            var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
 
            function turtle() {
                let turtle = {
                    pos: mat.clone(),
                    rot: mat.clone(),
                    rotVec3: new THREE.Vector3(0,0,0)
                };
                //turtle.pos.makeTranslation(0,len/2,0);
                //let turtle = geometry.clone();
                //turtle.scale(1,len,1);
                
                let turtleHistory = [];
                turtleHistory.push(turtle);
                //translate(width / 2, height);
                
                //len *= 0.99;
                for (let i = 0; i < sentence.length; i++) {    
                    let current = sentence.charAt(i);
                    turtle = turtleHistory[turtleHistory.length -1];
                    
                    //console.log(turtleHistory);
                    
                    if (current == 'F') {
                        geometry.applyMatrix4(turtle.rot);
                        geometry.translate(0,len,0);
                        //geometry.applyMatrix4(turtle.pos);
                        turtle.pos.makeTranslation(len*Math.cos(turtle.rotVec3.x),len*Math.cos(turtle.rotVec3.y),len*Math.cos(turtle.rotVec3.z));
                        //console.log(turtle.rot.elements);
                        scene.add(new THREE.Mesh( geometry.clone(), material ));
                    } else if (current == 'X') {
                        turtle.pos.makeTranslation(len*Math.cos(turtle.rotVec3.x),len*Math.cos(turtle.rotVec3.y),len*Math.cos(turtle.rotVec3.z));
                    } else if (current == '+') {
                        turtle.rot.makeRotationX(angle);
                        turtle.rotVec3.x += angle;
                    } else if (current == '-') {
                        turtle.rot.makeRotationX(-angle);
                        turtle.rotVec3.x -= angle;
                    } /*else if (current == '&') {
                        turtle.rot.makeRotationX(angle);
                    } else if (current == '^') {
                        turtle.rot.makeRotationX(-angle);
                    } else if (current == '%') {
                        turtle.rot.makeRotationZ(angle);
                    } else if (current == '/') {
                        turtle.rot.makeRotationZ(-angle);
                    } else if (current == '|') {
                        turtle.rot.makeRotationY(Math.PI);
                    } */
                    else if (current == '[') {
                        turtleHistory.push(turtle);
                    } else if (current == ']') {
                        turtleHistory.pop();
                    }
                }
            }
 
            generate();
            generate();
            //generate();
            //generate();
 
            controls.update();
 
            var animate = function () {
                requestAnimationFrame( animate );
 
                controls.update();
                renderer.render( scene, camera );               
            };
 
            animate();
        </script>
    </body>
</html>

