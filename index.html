<html>
    <head>
        <title>My first three.js app</title>
        <style>
            body { margin: 0; }
            canvas { display: block; }
        </style>
    </head>
    <body>
        <script src="three.js-master/build/three.js"></script>
        <script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
        <script>
            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
 
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            let controls = new THREE.OrbitControls( camera, renderer.domElement );
 
            camera.position.z = 10;
 
            let angle = 22.5 * Math.PI/180;
            let axiom = 'X';
            let sentence = axiom;
            let len = 10;
 
            let rules = [];
            
            rules[0] = {
                a: 'X',
                b: 'F+[[F]-X]-F[-FX]+X'
            };
            
            rules[1] = {
                a: 'F',
                b: 'FF' 
            };
 
            function generate() {
                //len *= 0.5;
                let nextSentence = '';
                for (let i = 0; i < sentence.length; i++) {
                    let current = sentence.charAt(i);
                    let found = false;
                    for (let j = 0; j < rules.length; j++) {
                        if (current == rules[j].a) {
                            found = true;
                            nextSentence += rules[j].b;
                            break;
                        }
                    }
                    if (!found) {
                        nextSentence += current;
                    }
                }
                sentence = nextSentence;
                console.log(sentence);
                turtle();
            }
 
            
            let geometry;
            let material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
 
            function turtle() {
                let turtle = {
                    // Up, Left, Head, can be compared to yaw, pitch, roll
                    u: new THREE.Vector3(1,0,0),
                    l: new THREE.Vector3(0,1,0),
                    h: new THREE.Vector3(0,0,1),
                    len: len,
                    pos: new THREE.Vector3(0,0,0),
                    rot: new THREE.Vector3(0,0,0)
                };
                
                let turtleHistory = [];
                turtleHistory.push(turtle);
                
                for (let i = 0; i < sentence.length; i++) {    
                    let current = sentence.charAt(i);
                    
                    if (current == 'F') {
                        turtle.len *= 0.8;
                        turtle.pos.x += turtle.len*Math.cos(turtle.rot.x);
                        turtle.pos.y += turtle.len*Math.sin(turtle.rot.y);
                        turtle.pos.z += turtle.len*Math.cos(turtle.rot.z);
                       
                        geometry = new THREE.CylinderGeometry(1, 1, turtle.len, 32 );
                        geometry.translate(turtle.pos.x,turtle.pos.y,turtle.pos.z);
                        
                        scene.add(new THREE.Mesh( geometry, material ));
                        geometry.rotateX(turtle.rot.x);
                        geometry.rotateY(turtle.rot.y);
                        geometry.rotateZ(turtle.rot.z);
                        
                    } else if (current == 'X') {
                        turtle.len *= 0.8;
                        turtle.pos.x += turtle.len*Math.cos(turtle.rot.x);
                        turtle.pos.y += turtle.len*Math.sin(turtle.rot.y);
                        turtle.pos.z += turtle.len*Math.cos(turtle.rot.z);
                    } else if (current == '+') {
                        turtle.rot.x += angle; //ska antagligen egentligen vara y för att följa samma grammar
                    } else if (current == '-') {
                        turtle.rot.x -= angle; //ska antagligen egentligen vara y för att följa samma grammar
                    } else if (current == '&') {
                        turtle.rot.y += angle; //ska antagligen egentligen vara x för att följa samma grammar
                    } else if (current == '^') {
                        turtle.rot.y -= angle; //ska antagligen egentligen vara x för att följa samma grammar
                    } else if (current == '%') {
                        turtle.rot.z += angle;
                    } else if (current == '/') {
                        turtle.rot.z -= angle;
                    } else if (current == '|') {
                        turtle.rot.y += Math.PI;
                    } else if (current == '[') {
                        turtleHistory.push(JSON.parse(JSON.stringify(turtle))); // Using Json-methods to make deep copy
                        turtle = turtleHistory[turtleHistory.length -1];
                    } else if (current == ']') {
                        turtleHistory.pop();
                        turtle = turtleHistory[turtleHistory.length -1];
                    }
                }
            }
 
            generate();
            generate();
            generate();
            generate();
 
            controls.update();
 
            let animate = function () {
                requestAnimationFrame( animate );
 
                controls.update();
                renderer.render( scene, camera );               
            };
 
            animate();
        </script>
    </body>
</html>

