<html>
	<head>
		<title>Lindenmayer System</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.js"></script>
		<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
		<script>
			let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			let controls = new THREE.OrbitControls( camera, renderer.domElement );
 
            camera.position.z = 25;
 
            let angle = 22.5 * Math.PI/180; // Conversion from degrees to radians
            let n = 5; // Number of iterations when generating sentence
            let axiom = 'X';
            let sentence = axiom;

			let rules = [];
            
			rules[0] = {
                a: 'X',
                b: 'F-[[X]+X]+F[+FX]-X'
			};

			rules[1] = {
                a: 'F',
                b: 'FF' 
			};


            // Generate sentence from rules/grammar
			function generate() {
				let nextSentence = '';
				for (let i = 0; i < sentence.length; i++) {
					let current = sentence.charAt(i);
					let found = false;
					for (let j = 0; j < rules.length; j++) {
						if (current == rules[j].a) {
							found = true;
							nextSentence += rules[j].b;
							break;
						}
					}
					if (!found) {
					nextSentence += current;
					}
				}
				sentence = nextSentence;
				//console.log(sentence);
			}
            

            let material = new THREE.MeshBasicMaterial( {color: 0xff5733} );
            
            function cylinderMesh(pointX, pointY, material) {
                let direction = new THREE.Vector3().subVectors(pointY, pointX);
                let orientation = new THREE.Matrix4();
                orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
                orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
                                                             0, 0, 1, 0,
                                                             0, -1, 0, 0,
                                                             0, 0, 0, 1));
                let edgeGeometry = new THREE.CylinderGeometry(0.1, 0.1, direction.length(), 8, 1);
                let edge = new THREE.Mesh(edgeGeometry, material);
                edge.applyMatrix4(orientation);
                // position based on midpoints - there may be a better solution than this
                edge.position.x = (pointY.x + pointX.x) / 2;
                edge.position.y = (pointY.y + pointX.y) / 2;
                edge.position.z = (pointY.z + pointX.z) / 2;
                return edge;
            }

 			
            function turtle() {
                let turtle = {
                    // Up, Left, Head, can be compared to yaw, pitch, roll
                    pos: new THREE.Vector3(0,0,0),
                    u: new THREE.Vector3(0,1,0),
                    l: new THREE.Vector3(1,0,0),
                    h: new THREE.Vector3(0,0,1)
                };
                
                let turtleHistory = [];
                turtleHistory.push(turtle);
                let arrayLength = 1;
                
                for (let i = 0; i < sentence.length; i++) {    
                    let current = sentence.charAt(i);
					
                    if (current == 'F') {
                        
						let point1 = turtle.pos;
                        
						let temp = turtle.u;
                        
                        let point2 = new THREE.Vector3().addVectors(point1, temp);
                        
                        // Draw a cylinder between the two points
                        scene.add(cylinderMesh(point1, point2, material));
                        
                        turtle.pos = point2;
                        
                    } else if (current == 'X') {
                        
                        let point1 = turtle.pos;

						let temp = turtle.u;
						
                        let point2 = new THREE.Vector3().addVectors(point1, temp);
                        
                        turtle.pos = point2;
                        
                    } else if (current == '+') {						
						let RuPos = new THREE.Matrix3();
						RuPos.set( Math.cos(angle), Math.sin(angle), 0,
                                  -Math.sin(angle), Math.cos(angle), 0,
                                   0		      , 0			   , 1);
                        
                        turtle.h.applyMatrix3(RuPos);
                        turtle.l.applyMatrix3(RuPos);
                        turtle.u.applyMatrix3(RuPos);

                    } else if (current == '-') {
                        let RuNeg = new THREE.Matrix3();
						RuNeg.set( Math.cos(-angle), Math.sin(-angle), 0,
                                  -Math.sin(-angle), Math.cos(-angle), 0,
                                   0		       , 0               , 1);
                        turtle.h.applyMatrix3(RuNeg);
                        turtle.l.applyMatrix3(RuNeg);
                        turtle.u.applyMatrix3(RuNeg);
                        
                    } else if (current == '&') {
                        //turtle.rot.y += angle;
                    } else if (current == '^') {
                        //turtle.rot.y -= angle;
                    } else if (current == '%') {
                        //turtle.rot.z += angle;
                    } else if (current == '/') {
                        //turtle.rot.z -= angle;
                    } else if (current == '|') {
                        //turtle.rot.y += Math.PI;
                    } else if (current == '[') {
                       
                        let turtleCopy = JSON.parse(JSON.stringify(turtle)); // Using Json-methods to make deep copy
                        
                        // Convert copied vectors into being once again instances of THREE.Vector3
                        turtleCopy.u = new THREE.Vector3(turtleCopy.u.x,turtleCopy.u.y,turtleCopy.u.z);
                        turtleCopy.h = new THREE.Vector3(turtleCopy.h.x,turtleCopy.h.y,turtleCopy.h.z);
                        turtleCopy.l = new THREE.Vector3(turtleCopy.l.x,turtleCopy.l.y,turtleCopy.l.z);
                        
                        arrayLength = turtleHistory.push(turtleCopy); // Array length not updated internally but is returned by push()
                        
                        turtle = turtleHistory[arrayLength -1];
                       
                    } else if (current == ']') {
                       
                        turtleHistory.pop();
                        arrayLength--;
                        turtle = turtleHistory[arrayLength -1];
                    }
                }
            }

            // Generate sentence from grammar and draw structure with turtle graphics
            for(let i = 0; i < n; i++)
                generate();
            turtle();


			controls.update();

			let animate = function () {
				requestAnimationFrame( animate );
				controls.update();
				renderer.render( scene, camera );	
			};

			animate();
		</script>
	</body>
</html>