<html>
	<head>
		<title>Lindenmayer System</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.js"></script>
		<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
		<script>
			let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

            // Resize canvas if/when window is resized
            window.addEventListener( 'resize', onWindowResize, false );
            
            function onWindowResize(){
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
			let controls = new THREE.OrbitControls( camera, renderer.domElement );
			
            camera.position.z = 25;

            let angle = 22 * Math.PI/180; // Conversion from degrees to radians
			let n = 4; // Number of iterations when generating sentence
            let axiom = 'F'; 
            let sentence = axiom;

			let rules = [];
			 
			rules[0] = {
			a: 'F',
			b: 'F[+F]F[-F]/F',
			c: 'F[+F]^F',
			d: 'F[-F]&F'
			};

            /*
			rules[0] = {
			a: 'F',
			b: 'F[+F]F[-F]/F',
			c: 'F[+F]^F',
			d: 'F+F/F'
			};*/


			// Generate sentence from rules/grammar
			function generate() {
				
				let nextSentence = '';
				for (let i = 0; i < sentence.length; i++) {
					let  current = sentence.charAt(i);
					let found = false;
					for (let j = 0; j < rules.length; j++) {
						if (current == rules[j].a) {
							found = true;
							let rand = Math.floor(Math.random() * 101)
							if(rand < 33) {
								nextSentence += rules[j].b;
							} else if(rand < 66) {
								nextSentence += rules[j].c;
							} else {
								nextSentence += rules[j].d;
							}							
							break;
						}
					}
					if (!found) {
					nextSentence += current;
					}
				}
				sentence = nextSentence;
				//console.log(sentence);
			}
            
            let colorMaterial = [];
            colorMaterial[0] = new THREE.MeshBasicMaterial( {color: 0xec6610} );
            colorMaterial[1] = new THREE.MeshBasicMaterial( {color: 0x3b484f} );
            colorMaterial[2] = new THREE.MeshBasicMaterial( {color: 0x13283c} );
            colorMaterial[3] = new THREE.MeshBasicMaterial( {color: 0x008081} );
            colorMaterial[4] = new THREE.MeshBasicMaterial( {color: 0xffffff} );
            let currentColorIndex = 0;

			function cylinderMesh(pointX, pointY, material,i) {
                let direction = new THREE.Vector3().subVectors(pointY, pointX);
                let orientation = new THREE.Matrix4();
                orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
                orientation.multiply(new THREE.Matrix4().set(1,  0, 0, 0,
                                                             0,  0, 1, 0,
                                                             0, -1, 0, 0,
                                                             0,  0, 0, 1));
                let edgeGeometry = new THREE.CylinderGeometry(0.1, 0.1, direction.length(), 8, 1);
                let edge = new THREE.Mesh(edgeGeometry, colorMaterial[currentColorIndex]);
                edge.applyMatrix4(orientation);
                // position based on midpoints - there may be a better solution than this
                edge.position.x = (pointY.x + pointX.x) / 2;
                edge.position.y = (pointY.y + pointX.y) / 2;
                edge.position.z = (pointY.z + pointX.z) / 2;
                return edge;
            }


			// Draw structure based on generated sentence
            function turtle() {
                let turtle = {
                    pos: new THREE.Vector3(0,-10,0),
                    // Up, Left, Head, can be compared to yaw, pitch, roll
					hlu: new THREE.Matrix3().set(0, 1, 0,
                                                 1, 0, 0,
                                                 0, 0, -1)
                };
					
                // Stack
                let turtleHistory = [turtle];
                
                
                for (let i = 0; i < sentence.length; i++) {    
                    let current = sentence.charAt(i);
                    
                    // Rotational matrices
                    let RuPos = new THREE.Matrix3().set( Math.cos(angle), Math.sin(angle), 0,
                                                        -Math.sin(angle), Math.cos(angle), 0,
                                                         0			    , 0		         , 1);
                    let RuNeg = new THREE.Matrix3().set( Math.cos(-angle), Math.sin(-angle), 0,
                                                        -Math.sin(-angle), Math.cos(-angle), 0,
                                                         0	  	         , 0               , 1);
                    let RlPos = new THREE.Matrix3().set(Math.cos(angle), 0, -Math.sin(angle),
                                                        0			   , 1,  0              ,
                                                        Math.sin(angle), 0,  Math.cos(angle));
                    let RlNeg = new THREE.Matrix3().set(Math.cos(-angle), 0, -Math.sin(-angle),
                                                        0		        , 1,  0               ,
                                                        Math.sin(-angle), 0,  Math.cos(-angle));
                    let RhPos = new THREE.Matrix3().set(1, 0              ,  0              ,
                                                        0, Math.cos(angle), -Math.sin(angle),
                                                        0, Math.sin(angle),  Math.cos(angle));
                    let RhNeg = new THREE.Matrix3().set(1, 0		       ,  0               ,
                                                        0, Math.cos(-angle), -Math.sin(-angle),
                                                        0, Math.sin(-angle),  Math.cos(-angle));
                    let Ru180 = new THREE.Matrix3().set( Math.cos(Math.PI), Math.sin(Math.PI), 0,
                                                        -Math.sin(Math.PI), Math.cos(Math.PI), 0,
                                                         0		          , 0		         , 1);

                    // Go forward one step. Draw a cylinder along path.
                    if (current == 'F') {
						let point1 = turtle.pos;
                        
						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);						
        
						let point2 = new THREE.Vector3().addVectors(point1, temp);

						scene.add(cylinderMesh(point1,point2,colorMaterial[currentColorIndex],i));

                        turtle.pos = point2;
                    }
                    // Samma som F?
                    // Eller rita som F men utan att uppdatera turtle?
                    else if (current == 'G') {
						let point1 = turtle.pos;
                        
						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);						
        
						let point2 = new THREE.Vector3().addVectors(point1, temp);

						scene.add(cylinderMesh(point1,point2,colorMaterial[currentColorIndex],i));

                        turtle.pos = point2;
                    }
                    // Go forward one step without drawing anything.
                    else if (current == 'X' || current == 'f') {
                        let point1 = turtle.pos;

						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);	
                        
                        let point2 = new THREE.Vector3().addVectors(point1, temp);
						
                        turtle.pos = point2;
                    } 
                    // Rotations around H, L or U
                    else if (current == '-') {
						turtle.hlu.multiply(RuPos);
                    } else if (current == '+') {                        
						turtle.hlu.multiply(RuNeg);
                    } else if (current == '&') {
						turtle.hlu.multiply(RlPos);
                    } else if (current == '^') {
						turtle.hlu.multiply(RlNeg);
                    } else if (current == '/') {
						turtle.hlu.multiply(RhPos);
                    } else if (current == '\\') {						
						turtle.hlu.multiply(RhNeg);
                    } else if (current == '|') {						
						turtle.hlu.multiply(Ru180);
                    }
                    // Save current state in stack
                    else if (current == '[') {
						turtleHistory.push({pos: turtle.pos, hlu: turtle.hlu.clone()});
                        turtle = turtleHistory[turtleHistory.length -1];
                    } 
                    // Go back to last saved state in stack and remove it from stack
                    else if (current == ']') {
                        turtleHistory.pop();
                        turtle = turtleHistory[turtleHistory.length -1];
                    }
                    // Rotate the turtle to vertical.
                    // Inte testad än
                    else if (current == '$') {
                        // L = (V x H) / |V x H|
                        let V = new THREE.Vector3(0,1,0); // V = direction opposite to gravity
                        let H = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);
                        let L = V.cross(H).divide(V.cross(H).normalize());
                        
                        let U = H.cross(L);
                        
                        turtle.hlu.set(H.x, L.x, U.x,
                                       H.y, L.y, U.y,
                                       H.z, L.z, U.z,);
                    }
                    // Increment the current color index
                    else if (current == '´') {
                        currentColorIndex = (currentColorIndex+1)% colorMaterial.length;
                    }
                }
            }

            // Generate the sentence and draw the structure 
			for(let i = 0; i < n; i++)
                generate();
            turtle();
	
			controls.update();

			let animate = function () {
				requestAnimationFrame( animate );
				controls.update();
				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>