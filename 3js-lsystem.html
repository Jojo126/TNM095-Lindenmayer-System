<html>
	<head>
		<title>Lindenmayer System</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.js"></script>
		<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
		<script>
			let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			let controls = new THREE.OrbitControls( camera, renderer.domElement );
			
            camera.position.z = 25;

            let angle = 22 * Math.PI/180; // Conversion from degrees to radians
			let n = 4; // Number of iterations when generating sentence
            let axiom = 'F'; 
            let sentence = axiom;

			let rules = [];
			 
			rules[0] = {
			a: 'F',
			b: 'F[+F]F[-F]/F',
			c: 'F[+F]^F',
			d: 'F[-F]&F'
			};

            /*
			rules[0] = {
			a: 'F',
			b: 'F[+F]F[-F]/F',
			c: 'F[+F]^F',
			d: 'F+F/F'
			};*/


			// Generate sentence from rules/grammar
			function generate() {
				
				let nextSentence = '';
				for (let i = 0; i < sentence.length; i++) {
					let  current = sentence.charAt(i);
					let found = false;
					for (let j = 0; j < rules.length; j++) {
						if (current == rules[j].a) {
							found = true;
							let rand = Math.floor(Math.random() * 101)
							if(rand < 33) {
								nextSentence += rules[j].b;
							} else if(rand < 66) {
								nextSentence += rules[j].c;
							} else {
								nextSentence += rules[j].d;
							}							
							break;
						}
					}
					if (!found) {
					nextSentence += current;
					}
				}
				sentence = nextSentence;
				//console.log(sentence);
			}

			let material = new THREE.MeshBasicMaterial( {color: 0xff5733} );

			function cylinderMesh(pointX, pointY, material,i) {
                let direction = new THREE.Vector3().subVectors(pointY, pointX);
                let orientation = new THREE.Matrix4();
                orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
                orientation.multiply(new THREE.Matrix4().set(1,  0, 0, 0,
                                                             0,  0, 1, 0,
                                                             0, -1, 0, 0,
                                                             0,  0, 0, 1));
                let edgeGeometry = new THREE.CylinderGeometry(0.1, 0.1, direction.length(), 8, 1);
                let edge = new THREE.Mesh(edgeGeometry, material);
                edge.applyMatrix4(orientation);
                // position based on midpoints - there may be a better solution than this
                edge.position.x = (pointY.x + pointX.x) / 2;
                edge.position.y = (pointY.y + pointX.y) / 2;
                edge.position.z = (pointY.z + pointX.z) / 2;
                return edge;
            }


			// Draw structure based on generated sentence
            function turtle() {
                let turtle = {
                    pos: new THREE.Vector3(0,-10,0),
                    // Up, Left, Head, can be compared to yaw, pitch, roll
					hlu: new THREE.Matrix3().set(0, 1, 0,
                                                 1, 0, 0,
                                                 0, 0, -1)
                };
					
                // Stack
                let turtleHistory = [turtle];
                
                
                for (let i = 0; i < sentence.length; i++) {    
                    let current = sentence.charAt(i);
                    
                    // Rotational matrices
                    let RuPos = new THREE.Matrix3().set( Math.cos(angle), Math.sin(angle), 0,
                                                        -Math.sin(angle), Math.cos(angle), 0,
                                                         0			    , 0		         , 1);
                    let RuNeg = new THREE.Matrix3().set( Math.cos(-angle), Math.sin(-angle), 0,
                                                        -Math.sin(-angle), Math.cos(-angle), 0,
                                                         0	  	         , 0               , 1);
                    let RlPos = new THREE.Matrix3().set(Math.cos(angle), 0, -Math.sin(angle),
                                                        0			   , 1,  0              ,
                                                        Math.sin(angle), 0,  Math.cos(angle));
                    let RlNeg = new THREE.Matrix3().set(Math.cos(-angle), 0, -Math.sin(-angle),
                                                        0		        , 1,  0               ,
                                                        Math.sin(-angle), 0,  Math.cos(-angle));
                    let RhPos = new THREE.Matrix3().set(1, 0              ,  0              ,
                                                        0, Math.cos(angle), -Math.sin(angle),
                                                        0, Math.sin(angle),  Math.cos(angle));
                    let RhNeg = new THREE.Matrix3().set(1, 0		       ,  0               ,
                                                        0, Math.cos(-angle), -Math.sin(-angle),
                                                        0, Math.sin(-angle),  Math.cos(-angle));
                    let Ru180 = new THREE.Matrix3().set( Math.cos(Math.PI), Math.sin(Math.PI), 0,
                                                        -Math.sin(Math.PI), Math.cos(Math.PI), 0,
                                                         0		          , 0		         , 1);
                    
                    // Make all but first chylinder blue
                    /*
                    if(i > 0) {
                        material = new THREE.MeshBasicMaterial( {color: 0x0000ff} );
					}
                    */

                    // Go forward one step. Draw a cylinder along path.
                    if (current == 'F') {
						let point1 = turtle.pos;
                        
						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);						
        
						let point2 = new THREE.Vector3().addVectors(point1, temp);

						scene.add(cylinderMesh(point1,point2,material,i));

                        turtle.pos = point2;
                    }
                    // Samma som F?
                    else if (current == 'G') {
						let point1 = turtle.pos;
                        
						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);						
        
						let point2 = new THREE.Vector3().addVectors(point1, temp);

						scene.add(cylinderMesh(point1,point2,material,i));

                        turtle.pos = point2;
                    }
                    // Go forward one step without drawing anything.
                    else if (current == 'X') {
                        let point1 = turtle.pos;

						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);	
                        
                        let point2 = new THREE.Vector3().addVectors(point1, temp);
						
                        turtle.pos = point2;
                    } 
                    // Rotations around H, L or U
                    else if (current == '-') {
						turtle.hlu.multiply(RuPos);
                    } else if (current == '+') {                        
						turtle.hlu.multiply(RuNeg);
                    } else if (current == '&') {
						turtle.hlu.multiply(RlPos);
                    } else if (current == '^') {
						turtle.hlu.multiply(RlNeg);
                    } else if (current == '/') {
						turtle.hlu.multiply(RhPos);
                    } else if (current == '\\') {						
						turtle.hlu.multiply(RhNeg);
                    } else if (current == '|') {						
						turtle.hlu.multiply(Ru180);
                    }
                    // Save current state in stack
                    else if (current == '[') {
						turtleHistory.push({pos: turtle.pos, hlu: turtle.hlu.clone()});
                        turtle = turtleHistory[turtleHistory.length -1];
                    } 
                    // Go back to last saved state in stack and remove it from stack
                    else if (current == ']') {
                        turtleHistory.pop();
                        turtle = turtleHistory[turtleHistory.length -1];
                    }
                }
            }

            // Generate the sentence and draw the structure 
			for(let i = 0; i < n; i++)
                generate();
            turtle();
	
			controls.update();

			let animate = function () {
				requestAnimationFrame( animate );
				controls.update();
				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>