<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.js"></script>
		<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			let controls = new THREE.OrbitControls( camera, renderer.domElement );
			
            camera.position.z = 25;


            //camera.position.y = 25;
 			//camera.lookAt(new Vector3(0,0,0))
            let angle = 22 * Math.PI/180; // Conversion from degrees to radians
			let n = 4; // Number of iterations when generating sentence
            let axiom = 'F'; 
            let sentence = axiom;
            
			//let len = 10;

			var rules = [];
			 
			
			rules[0] = {
			a: 'F',
			b: 'F[+F]F[-F]/F',
			c: 'F[+F]^F',
			d: 'F[-F]&F'
			};

            /*
			rules[0] = {
			a: 'F',
			b: 'F[+F]F[-F]/F',
			c: 'F[+F]^F',
			d: 'F+F/F'
			};*/


			//console.log(rules[0]);


			// Generate sentence from rules/grammar
			function generate() {
				
				let nextSentence = '';
				for (var i = 0; i < sentence.length; i++) {
					let  current = sentence.charAt(i);
					let found = false;
					for (var j = 0; j < rules.length; j++) {
						if (current == rules[j].a) {
							found = true;
							let rand = Math.floor(Math.random() * 101)
							//rand = 100;
							if(rand < 33){
								nextSentence += rules[j].b;
							} else if(rand < 66){
								nextSentence += rules[j].c;
							}else{
								nextSentence += rules[j].d;
							}
							//console.log(rand);

							
							break;
						}
					}
					if (!found) {
					nextSentence += current;
					}
				}
				sentence = nextSentence;
				console.log(sentence);
				//turtle();
			}

			let material = new THREE.MeshBasicMaterial( {color: 0xff5733} );

			function cylinderMesh(pointX, pointY, material,i) {
                let direction = new THREE.Vector3().subVectors(pointY, pointX);
                let orientation = new THREE.Matrix4();
                orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
                orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
                                                             0, 0, 1, 0,
                                                             0, -1, 0, 0,
                                                             0, 0, 0, 1));
                let edgeGeometry = new THREE.CylinderGeometry(0.1, 0.1, direction.length(), 8, 1);
                let edge = new THREE.Mesh(edgeGeometry, material);
                edge.applyMatrix4(orientation);
                // position based on midpoints - there may be a better solution than this
                edge.position.x = (pointY.x + pointX.x) / 2;
                edge.position.y = (pointY.y + pointX.y) / 2;
                edge.position.z = (pointY.z + pointX.z) / 2;
                return edge;
            }


			
			
 			
            function turtle() {
                let turtle = {
                    // Up, Left, Head, can be compared to yaw, pitch, roll
                    u: new THREE.Vector3(0,1,0),
                    l: new THREE.Vector3(1,0,0),
                    h: new THREE.Vector3(0,0,-1),
                    
                    pos: new THREE.Vector3(0,-10,0),
					
					hlu: new THREE.Matrix3()
					
                };
				

				//let hlu = new THREE.Matrix3();

				turtle.hlu.set(
						0, 1, 0,
						1, 0, 0,
						0, 0, -1);
					
				

                
                let turtleHistory = [];
                turtleHistory.push(turtle);
                let arrayLength = 1;


                for (let i = 0; i < sentence.length; i++) {    
                    let current = sentence.charAt(i);
					//console.log(turtle.len);
                    
				if(i>0){
					material = new THREE.MeshBasicMaterial( {color: 0x0000ff} );
					}


                    if (current == 'F') {
						let point1 = turtle.pos;
						//let temp = turtle.u;						
						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);						
        
						let point2 = new THREE.Vector3().addVectors(point1, temp);

						scene.add(cylinderMesh(point1,point2,material,i));

						

                        turtle.pos = point2;
                    } else if (current == 'G') {
						let point1 = turtle.pos;
						//let temp = turtle.u;						
						let temp = new THREE.Vector3(turtle.hlu.elements[0],turtle.hlu.elements[3],turtle.hlu.elements[6]);						
        
						let point2 = new THREE.Vector3().addVectors(point1, temp);

						scene.add(cylinderMesh(point1,point2,material,i));


                        turtle.pos = point2;

                    } else if (current == 'X') {
                        let point1 = turtle.pos;

						let temp = turtle.u;
						
                        let point2 = new THREE.Vector3().addVectors(point1, temp);
                        
                        turtle.pos = point2;
                    } else if (current == '-') {
						//.rot.x += angle; //ska antagligen egentligen vara y för att följa samma grammar
						
						let RuPos = new THREE.Matrix3();
						RuPos.set(	Math.cos(angle)	,Math.sin(angle),0,
									-Math.sin(angle),Math.cos(angle),0,
									0				,0				,1);

						turtle.h.applyMatrix3(RuPos);
                        turtle.l.applyMatrix3(RuPos);
                        turtle.u.applyMatrix3(RuPos);

						turtle.hlu.multiply(RuPos);

                    } else if (current == '+') {

                        let RuNeg = new THREE.Matrix3();
						RuNeg.set( Math.cos(-angle), Math.sin(-angle), 0,
                                  -Math.sin(-angle), Math.cos(-angle), 0,
                                   0		       , 0               , 1);
                        turtle.h.applyMatrix3(RuNeg);
                        turtle.l.applyMatrix3(RuNeg);
                        turtle.u.applyMatrix3(RuNeg);

						turtle.hlu.multiply(RuNeg);


                    } else if (current == '&') {
                        let RlPos = new THREE.Matrix3();
						RlPos.set(	Math.cos(angle)		,0	,-Math.sin(angle),
                                	0					,1	,0,
									Math.sin(angle)	,0	,Math.cos(angle));
                        turtle.h.applyMatrix3(RlPos);
                        turtle.l.applyMatrix3(RlPos);
                        turtle.u.applyMatrix3(RlPos);
					

						turtle.hlu.multiply(RlPos);

                    } else if (current == '^') {
                        let Rlneg = new THREE.Matrix3();
						Rlneg.set(	Math.cos(-angle)	,0	,-Math.sin(-angle),
                                	0					,1	,0,
									Math.sin(-angle)	,0	,Math.cos(-angle));
                        turtle.h.applyMatrix3(Rlneg);
                        turtle.l.applyMatrix3(Rlneg);
                        turtle.u.applyMatrix3(Rlneg);

						turtle.hlu.multiply(Rlneg);
						//console.log("hej");

                    } else if (current == '/') {
                        let RhPos = new THREE.Matrix3();
						RhPos.set(	1	,0					,0,
                                0	,Math.cos(angle)	,-Math.sin(angle),
								0	,Math.sin(angle)	,Math.cos(angle));
                        turtle.h.applyMatrix3(RhPos);
                        turtle.l.applyMatrix3(RhPos);
                        turtle.u.applyMatrix3(RhPos);

						turtle.hlu.multiply(RhPos);

                    } else if (current == '\\') {
                        let Rhneg = new THREE.Matrix3();
						Rhneg.set(	1	,0					,0,
                                	0	,Math.cos(-angle)	,-Math.sin(-angle),
									0	,Math.sin(-angle)	,Math.cos(-angle));
                        turtle.h.applyMatrix3(Rhneg);
                        turtle.l.applyMatrix3(Rhneg);
                        turtle.u.applyMatrix3(Rhneg);
						
						turtle.hlu.multiply(Rhneg);

                    } else if (current == '|') {
                        let Ru180 = new THREE.Matrix3();
						Ru180.set(	Math.cos(Math.PI)	,Math.sin(Math.PI),0,
									-Math.sin(Math.PI)	,Math.cos(Math.PI),0,
									0				,0				,1);

						turtle.h.applyMatrix3(Ru180);
                        turtle.l.applyMatrix3(Ru180);
                        turtle.u.applyMatrix3(Ru180);
						
						turtle.hlu.multiply(Ru180);

                    } else if (current == '[') {
                        let turtleCopy = JSON.parse(JSON.stringify(turtle)); // Using Json-methods to make deep copy
                        
                        // Convert copied vectors into being once again instances of THREE.Vector3
                        turtleCopy.u = new THREE.Vector3(turtleCopy.u.x,turtleCopy.u.y,turtleCopy.u.z);
                        turtleCopy.h = new THREE.Vector3(turtleCopy.h.x,turtleCopy.h.y,turtleCopy.h.z);
                        turtleCopy.l = new THREE.Vector3(turtleCopy.l.x,turtleCopy.l.y,turtleCopy.l.z);
						
						let hlu = turtleCopy.hlu;
						
						turtleCopy.hlu = new THREE.Matrix3();
						

                        turtleCopy.hlu.set(	hlu.elements[0],hlu.elements[3],hlu.elements[6],
											hlu.elements[1],hlu.elements[4],hlu.elements[7],
											hlu.elements[2],hlu.elements[5],hlu.elements[8]);
						
						
                        
						arrayLength = turtleHistory.push(turtleCopy); // Array length not updated internally but is returned by push()
                        
                        turtle = turtleHistory[arrayLength -1];
                    } else if (current == ']') {
                        turtleHistory.pop();
                        arrayLength--;
                        turtle = turtleHistory[arrayLength -1];
                    }
                }
            }

			for(let i = 0; i < n; i++)
                generate();
            turtle();
	
			controls.update();

			var animate = function () {
				requestAnimationFrame( animate );

				/*cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;
				*/
				//console.log(camera.lookAt);
				controls.update();
				renderer.render( scene, camera );
				
			};

			animate();
		</script>
	</body>
</html>